# C语言基础知识

![](https://doc.shiyanlou.com/c/3-5.jpg)

## 1、第一个c语言程序

```c
#include <stdio.h>          //引用头文件
int main()          		//main函数为c语言程序入口，有且只有一个main函数
{
    printf("Hello World!"); //打印
    return 0;				//返回
}
```

一个完整的C语言程序，是由一个、且只能有一个**`main()`**函数和若干个其他函数结合而成。

main函数是程序的入口，即程序从main函数开始执行。

## 2、c数据类型及语句

### 2.1 关键字

#### 2.1.1 数据类型相关的关键字

`char`、`short`、`int`、`long`、`float`、`double`、`struct`、`union`、`enum`、`signed`、`unsigned`、`void`

|   关键字   |                            类型                            | 字节 |
| :--------: | :--------------------------------------------------------: | :--: |
|   `char`   |                           字符型                           |  1   |
|  `short`   |                           短整型                           |  2   |
|   `int`    |                            整形                            |  4   |
| `long int` |                           长整型                           |  4   |
|  `float`   |                      单浮点型（实型）                      |  4   |
|  `double`  |                      双浮点型（实型）                      |  8   |
|  `struct`  |                      与结构体类型有关                      |      |
|  `union`   |                   与共用体（联合体)有关                    |      |
|   `enum`   |                       与枚举类型有关                       |      |
|  `signed`  |                  有符号（正负），一般省略                  |      |
| `unsigned` |                   无符号，只保存正数和0                    |      |
|   `void`   | 用来修饰函数的参数或者返回值，代表函数没有参数或没有返回值 |      |

#### 2.1.2存储相关关键字

`register`、`static`、`const`、~~`auto`~~、`extern`

1. **`register`**是寄存器的意思，用register修饰的变量是寄存器变量，==尽量==将其存储空间分配在寄存器中。不能对寄存器变量取地址，==只有==存放在内存中的数据才有地址。
2. **`static`**是静态的意思。static可以修饰全局变量、局部变量、函数
3. **`const`** 是常量的意思。用const修饰的变量是只读的，不能修改它的值。const可以修饰指针。
4. **`auto`**基本不用
5. **`extern`**是外部的意思，一般用于函数和全局变量的声明。

#### 2.1.3控制语句相关的关键字

`if`、`else`、`break`、`continue`、`for`、`while`、`do`、`switch`、`case`、`goto`、`default`

#### 2.1.4其他关键字

`sizeof`、`typedef`、`volatile`

1. **`sizeof`** 用来测变量、数组的占用存储空间的大小（字节）
2. `**typedef** `重命名相关的关键字

```c
#include <stdio.h>
typedef int INT4；
int main()
{
    int a = 1;
    INT4 b = 2;
    printf("a = %d\n", a);
    printf("b = %d\n", b);
    return 0;
}
```

3. **`volatile`**是易改变的意思。用volatile定义的变量是易改变的，每次用volatile变量时，重新去内存中取保证用的是最新的值，而不是寄存器中的备份。

### 2.2数据类型

#### 2.2.1基本数据类型

![](https://doc.shiyanlou.com/c/4-8.jpg)

![](https://doc.shiyanlou.com/c/4-7.jpg)

![](https://doc.shiyanlou.com/c/5-4.jpg)



`char`、`short int`、`int`、`long int`、`float`、`double`

常量：程序运行中其值可以改变的量

变量：程序运行中其值不能改变的量

八进制：以数字==0==开头

十六进制：以==0x==开头。0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F。

`float`：占4个字节，==7==位有效数字，指数-37~38

`double`：占8个字节，==16==位有效数字，指数-307~308
==**格式化输出字符**==

|格式化字符|对应数据类型|含义|
|:---:|:------:|:--------:|
|`%d`|int|十进制有符号整数|
|`%u`|unsigned int|无符号十进制无符号整数|
|`%o`|unsigned int|无符号八进制表示的整数|
|`%x`,`%X`|unsigned int|无符号十六进制表示的整数 , `x`对应`abcdef`，`X`对应`ABCDEF`|
|`%f`|float|float类型浮点数|
|`%lf`|double|double类型浮点数|
|`%e`,`%E`|double|科学计数法表示的数，此处“e”，“E”表示在输出时用的字符|
|`%s`|char *|字符串|
|`%c`|char|单个字符|
|`%p`|void *|十六进制形式输出指针|
|`%hd`|short int|短整型|
|`%hu`|unsigned short|无符号短整型|

==特殊==

> `%3d`：要求宽度为三位，不足三位，前面空格补齐；

> `%03d`：要求宽度为三位，不足三位，前面0补齐：

> `%-3d`：要求宽度为三位，不足三位，后面空格补齐：

> `%.3f`：小数点后保留三位
>
> **小知识点：**
>
> 1. 在输入函数时，用 %c 格式声明输入字符时，空格字符和转义字符都是作为有效字符输入，例如：`scanf("%c%c%c",&c1,&c2,&c3);` 在执行这个程序时，需要我们连续输入 3 个字符，中间不要有空格，如下： `abc` 下面插入空格的形式是错误的： `a b c`
>
> - 这种形式第一个字符 'a' 送给 c1，第二个字符是空格字符' '送给了 c2，第三个字符 'b' 送给了 c3。
>
> 1. 在使用 %d 输出时，我们可以指定输出的宽度。具体用法:
>
> - `%d`：按照整型数据的实际长度输出。
> - `%md`：以 m 为指定的最小字段宽度输出，右对齐。
> - `%ld`：输出长整型数据。
> - `%mld`：输出指定宽度的长整型数据。

#### 2.2.2构造类型

> 概念：由若干个相同或不同类型数据构成的集合，为构造类型。

> 数组、结构体、共用体、枚举

#### 2.2.3类型转换

+ 自动转换
  1. 占用内存字节数少（值域小）的类型，向占用内存字节数多（值域大）的类型转换，以保证精度不降低。
+ 强制转换
  1. 把表达式的运算结果强制转换成类型说明符所表示的类型。
  2. 类型说明符必须加==括号==。

#### 2.2.4指针

### 2.3运算符

#### 2.3.1运算符

> 用算数运算符将运算对象（也称操作数）连接起来的、符合C语法规则的式子，称为C算术表达式。运算对象包括常量、变量、函数等。

#### 2.3.2运算符的分类

1. 双目运算符：参加运算的操作数有两个

2. 单目运算符：参加运算的操作数只有一个。

   - `++`自增、`--`自减

3. 三目运算符：参加运算的操作数有三个

   **`()?():()`**

#### 2.3.3算术运算符

|算术运算符|含义|
|:------:|:-------:|
|`+`|加|
|`-`|减|
|`*` |乘|
|`/`|除|
|`%`|取余|

#### 2.3.4关系运算符

|关系运算符|含义|
|:----:|:----:|
|`>`|大于|
|`<`|小于|
|`==`|等于|
|`<=`|小于等于|
|`>=`|大于等于|
|`!=`|不等于|

#### 2.3.5逻辑运算符

1. `&&` 逻辑与
   - 两个条件都为真，则结果为真

2. `|| `逻辑或
   - 两个条件至少有一个为真，则结果为真

3. `！`  逻辑非
   - 真为假，假为真

#### 2.3.6位运算符

**无论正数还是负数，编译系统都是按照内存中存储的内容进行位运算**

> 原码：将一个整数，转换为二进制，则就是其原码。
>
> 反码：正数的反码是其原码；负数的反码是将原码中，除符号位以外，每一位取反。
>
> 补码：正数的补码是其原码，负数的补码是其反码+1



1. `&` 按位与
   - 同为1则为1，不同为0
2. `|` 按位或
   - 有1为1，同为0则为0
3. `~` 按位取反
   - 1变0，0变1

4. `^` 按位异或
   - 相同为0，相异为1

5. 位移
   - `<<`左移。
   - `>>`右移。注意右移分：逻辑右移、算术右移
     - 逻辑右移：高位补0，低位溢出
     - 算术右移（取决于编译器）：高位补==符号位==，低位溢出

#### 2.3.7条件运算符号

格式：`()?():()`

**==(条件表达式)?(若真，则执行):(若假，则执行)==**

#### 2.3.8逗号运算符

`(),()`

注意逗号运算符的结果是后面表达式的结果

#### 2.3.9自增自减运算符

`i++`、`i--`

运算符在变量后面，在表达式中先用i的值，下条语句i的值才会改变

```c
#include <stdio.h>
int main()
{
    int i = 3;
    int num;
    num = i++;
    printf("num=%d,i=%d\n",num, i);	//num=3, i=4
    return 0;
}
```



==`++i`==、==`--i`==

运算符在变量前面，先加，再用

```c
#include <stdio.h>
int main()
{
    int i = 3;
    int num;
    num = ++i;
    printf("num=%d,i=%d\n",num, i)	//num=4, i=4
    return 0;
}
```

拓展

```c
#include <stdio.h>
int main()
{
    int i = 3;
    int num;
    num = (i++)+(i++)+(i++);
    printf("%num=%d,i=%d\n",num,i);		//num=9,i=6
    return 0;
}
```

```c
#include <stdio.h>
int main()
{
    int i = 3;
    int num;
    num = (++i)+(++i)+(++i);
    printf("%num=%d,i=%d\n",num,i);		//num=18,i=6
    return 0;
}
```

#### 2.3.10运算优先级及结合性

运算符优先级

> 在表达式中按照优先级先后进行运算，优先级高的先于优先级低的先运算

运算符结合性

> 左结合性 --->
>
> 右结合性 <---

### 2.4控制语句

#### 2.4.1选择控制语句

##### **`if`** 语句

- `if `语句

```c
if(条件表达式)

{
	语句1；
	语句2；
	……
}
```

> 如果条件成立执行大括号里的所有语句，不成立的话大括号里的语句不执行

- `**if-else**`

```c
if(条件表达式)
{
    语句;
}
else
{
    语句;
}
```

> 如果if的条件成立，执行if后面{}内的语句，否则执行else后面{}的语句

- **i`f-else if -else`**

```c
if(条件表达式)
{ 
    
}
else if(条件表达式)
{
    
}
……
else
{
    
}
```

> 在判断的时候，从上往下判断，一旦有成立的表达式，执行对应的复合语句，下面的不再进行判断，各个条件判断是互斥的。

##### **`switch`** 语句

```c
switch(表达式)		//表达式只能是字符型或整形的
{
	case 常量表达式1;
        语句1;
        break;
    case 常量表达式2;
        语句2;
        break;
    ……
    default:
        语句3;
        break;
}
```

#### 2.4.2循环控制语句

##### **`for`** 循环

```c
for(表达式1;表达式2;表达式3)
{
    循环语句;
}
```

- 第一次进入循环的时候执行表达式1，表达式1只执行一次
- 表达式2是循环的条件，只有表达式2为真，才执行循环体，即每次进入循环体前要判断表达式2是否为真
- 每次执行完循环体后，首先执行表达式3

```c
 //for循环求1~100的和
 #include <stdio.h>
 int main()
 {
     int i;
     int sum=0;
     for(i=1;i<=1;i++)
     {
         sum+=i;
     }
     printf("%d",sum);
     return 0;
 }
```

```c
  //for循环嵌套，打印九九乘法表
  #include <stdio.h>
  int main()
  {
      int i,j;
      for(i=1;i<=9;i++)
      {
          for(j=1;j<=i;j++)
          {
              printf("%d*%d=%d ",j,i,i*j);
          }
          printf("\n");
      }
      return 0;
  }
```

##### **`while`** 循环

   - 形式1

   ```c
   while(条件表达式)
   {
       复合语句；
   }
   ```

   > 进入while循环的时候，首先会判断条件表达式是否为真，为真进入循环体，否则退出循环。

   ```c
   #include <stdio.h>
   int main()
   {
   	int i=1;
       int sum=0;
       while(i<=100)
       {
           sum+=i;
           i++;
       }
       printf("%d",sum);
       return 0;
   }
   ```

   - 形式2

    ```c
    do(循环体)
    {
    }while(条件表达式)
    ```

   > 先执行循环体里的代码，然后去判断表达式是否为真，为真再次执行循环体，否则退出循环

    ```c
    #include <stdio.h>
    int main()
    {
        int i=1;
        int sum=0;
        do{
            sum+=i;
            i++;
        }while(i<=100);		//注意此处分号
         printf("%d",sum);
        return 0;
    }
    ```

##### **`goto`**

```c
#include <stdio.h>
int main()
{
    printf("1");
    printf("2");
    goto tmp;
    printf("3");
    printf("4");
    printf("5");
    tmp:				//定义标签，goto与标签tmp中的语句都不会被执行，注意标签后面是冒号
    printf("6");
    printf("7");
    printf("8");
    return 0;
}
```

## 3、数组

### 3.1数组的概念

> 数组是若干个相同类型的变量在内存中有序存储的集合。

### 3.2数组的分类

#### 3.2.1按元素的类型分类

##### 1. 字符数组

   > 若干个字符变量的集合
   >
   > `char s[10]`

##### 2. 短整型的数组

   > `short int a[10]`

##### 3. 整型数组

   > `int a[10]`

##### 4. 长整型数组

   > `long int a[10]`

##### 5. 浮点型数组

   > `float a[10]`
   >
   > `double a[10]`

##### 6. 指针数组

   > `char \*a[10]`
   >
   > `int \*a[10]`

##### 7. 结构体数组

   > `struct stud boy[10]`

#### 3.2.2按维数分类

##### 1.一维数组

> `int a[10]`
>
> 一行

##### 2.二维数组

> `int a\[2]\[5]`
>
> 两行五列，可以看成由多个一维数组构成的

##### 3.多维数组

> `int a\[4]\[2]\[10]`

### 3.3数组的定义

> 定义一个数组，在内存里分配空间

#### 3.3.1一维数组的定义

> 定义数组的时候可以不给出数组元素的个数，根据初始化的个数来确定数组的大小。
>
> 格式：
>
> ​	数据类型	数组名	数组个数
>
> ​	`int		a	[10]`
>
> ​	`char	b	[10]`

#### 3.3.2二维数组的定义

> 二维数组在定义时可以不给出行数，但必须给出列数
>
> 格式：
>
> ​	数据类型	数组名	 \[行的个数]\[列的个数]
>
> ​	`int		a		[4][5]`
>
> ​	`char	b		[4][5] `

### 3.4数组的初始化

> 定义数组的时候，顺便给数组的元素赋初值，即开辟空间的同时并且给数组元素赋值

#### 3.4.1一维数组的初始化

1. 全部初始化

   ```c
   int a[3] = {1,2,3};		//a[0]=1;a[1]=2;a[2]=3
   ```

2. 部分初始化

   ```c
   int a[5]={1,2,3};		//初始化赋值不够后面补0，a[3]=0;a[4]=0
   注意：只能省略后面元素，可以不初始化，不能中间的不初始化
   ```

#### 3.4.2二维数组的定义并初始化

1. 按行初始化

   - 全部初始化

     ```c
     int a[2][2]={{1,2},{3,4}};
     ```

   - 部分初始化

     ```c
     int a[3][3]={{1,2},{1}};
     ```

2. 逐个初始化

   - 全部初始化

     ```c
     int a[2][3]={1,2,3,4,5,6};
     ```

   - 部分初始化

     ```c
     int a[2][3]={1,2,3,4};
     ```

### 3.5数组元素的引用方法

#### 3.5.1一维数组元素的引用方法

> 数组名	[下标]	//下标代表数组元素在数组中的位置

#### 3.5.2二维数组元素的引用方法

> 数组名	\[行下标]\[列下标]

#### 3.5.3字符数组

1. 字符数组的引用
   + 用字符串方式赋值比用字符逐个赋值要多占1个字节，用于存放字符串结束标志**”\0“**

## 4、函数

### 4.1函数的分类

> 函数是C语言的功能单位，实现一个功能可以封装一个函数来实现。
>
> 定义函数的时候一切以功能为目的，**根据功能去定义函数的参数和返回值**

### 4.2函数的分类

1. 从定义角度分类（即函数是谁实现）
   - 库函数（C库实现的）
   - 自定义函数（程序员自己实现的函数）
   - 系统调用（操作系统实现的函数）
2. 从参数角度分类
   - 有参函数
     - 函数有形参，可以是一个，或者多个，参数的类型随便，完全取决于函数的功能
   - 无参函数
     - 函数没有参数，在形参列表的位置写个void或者什么都不写
3. 从返回值角度分类
   - 带返回值的参数
     - 在定义函数的时候，必须带着返回值类型，在函数体里，必须有return，如果没有返回值类型，默认返回==整型==
   - 无返回值的函数
     - 在定义函数的时候，函数名字前面加void

### 4.3函数的定义

> 函数的定义即函数的实现

1. 函数的定义方法

   > **形参必须带类型，而且以逗号分隔**
   >
   > **函数的定义不能嵌套，即不能在一个函数体内定义另外一个函数，所有函数的定义是平行的**
   >
   > **在一个程序中，函数只定义一次，给函数命名时，尽量见名知意，且符合C语言命名规则**

   ```c
   返回值类型	函数名字（形参列表）
   {
       //函数体，函数的功能在函数体力实现
   }
   ```

### 4.4函数的声明

1. 概念

   > 对已经定义的函数，进行说明。函数的声明可以声明多次

2. 为什么要申明

   > 有些情况下，如果不对函数进行声明，编译器在编译的时候，可能不认识这个函数，因为编译器在编辑C程序的时候，是从上往下进行编译的

3. 声明的方法

   > 什么时候需要声明
   >
   > 1. 主调函数和被调函数==在==同一个.c文件中
   >    - **被调函数在上，主调函数在下（不需要声明）**
   >    - 被调函数在下，主调函数在上
   >
           > 声明方法：
           >
           > 1. 直接声明
           >    - **将被调用的函数的第一行拷贝过去，后面加分号**
           > 2. 间接声明
           >    - **将函数的声明放在头文件中，.c程序包含头文件即可**
   
     2. 主调函数和被调函数==不在==同一个.c文件中的时候（**一定要声明**）
     
        > 声明方法：
        >
        > 1. 直接声明
        >    - **将被调用的函数的第一行拷贝过去，后面加分号，前面加==extern==**
        > 2. 间接声明
        >    - 将函数的声明放在头文件中，.c程序包含头文件即可

### 4.5函数的调用

1. 有无返回值

   - 有返回值的，根据返回值类型，需要在主调函数中定义一个对应类型的变量，接收返回值

   - 无返回值，不需要接收返回值

2. 有无形参

   - 函数名（实参列表）；//带形参的
   - 函数名（）；//没有形参的

### 4.6函数总结

> 在定义函数的时候，关于函数的参数和返回值类型是什么情况，完全取决于函数的功能
>
> 使用函数的好处
>
> - 定义一次，可以调用多次，减少代码的冗余度
> - 使代码模块化更好，方便调试程序，且方便阅读

### 4.7变量的存储类别

#### 4.7.1内存的分区

1. 内存：物理内存、虚拟内存。操作系统会在物理内存和虚拟内存之间做映射
2. 在运行程序的时候，操作系统会将 虚拟内存 进行分区
   - 堆：
     - 在动态申请内存时，在堆里开辟内存
   - 栈:
     - 主要存放局部变量
   - 静态全局区：
     - 未初始化的静态全局区
       - 静态变量（static修饰）、未初始化的全局变量
     - 初始化的静态全局区
       - 赋过初值的全局变量、静态变量
   - 代码区：
     - 存放程序代码
   - 文字常量区：
     - 存放常量

#### 4.7.2普通的全局常量

1. 概念：
   - 在函数外部定义的变量
2. 作用范围：
   - 全局变量的作用范围是程序的==所有地方==，使用前需要声明：`extern int num`  注意声明的时候==不要赋值==
3. 生命周期：
   - 程序运行的整个过程，一直存在，直到程序结束

`注意：定义普通的全局变量的时候，如果不赋初值，则默认值为0`

#### 4.7.3静态全局变量 **`static`**

1. 概念：
   - 定义全局变量的时候前面用**`static`**修饰
2. 作用范围：
   - `static`限定了静态全局变量的作用范围，只能在它定义的==**.c**（源文件）中有效==
3. 生命周期：
   - 在程序运行的整个过程一直存在

`注意：定义静态全局变量时如果不赋初值，它的默认值为0`

#### 4.7.4普通的全局变量

1. 概念：
   - 在函数内部定义的或者在复合语句中定义的变量
2. 作用范围：
   - 在函数中定义的变量，在它的函数中有效
   - 在复合语句中定义的变量，在它的复合语句中有效
3. 生命周期：
   - 在函数调用之前，局部变量**不占空间**，调用函数的时候才为局部变量开辟空间，函数结束了，局部变量就==释放==了，在复合语句中定义的局部变量一样如此。

#### 4.7.5静态的局部变量

1. 概念：
   - 定义局部变量时，前面加**`static`**修饰
2. 作用范围：
   - 在它定义的函数或复合语句中有效
3. 生命周期：
   - 第一次调用函数的时候，开辟空间赋值，函数结束后==**不释放**==，以后再次调用函数时，不再为其开辟空间，也不赋初值，使用==之前的变量==

```c
注意：
1. 定义普通局部变量，如果不赋初值，它的值是==随机的==
   定义静态局部变量，如果赋初值，它的值为==0==
2. 普通全局变量和静态全局变量如果不赋初值，它的值为==0==
```

> 在同一作用范围内，不允许变量重名。
>
> 作用范围不同的可以重名。
>
> 局部范围内，重名的全局变量不起作用。（就近原则）

#### 4.7.6外部函数

> 自定义函数都是外部函数，即函数可以在程序的任何一个文件中调用

#### 4.7.7内部函数

> 在定义函数的时候，**==返回值==**前面加==**`static*`*==修饰
>
> `static`限定了函数的作用范围，在定义的 .c 中有效
>
> 区别：
>
> > 1. 外部函数：在所有地方都可以调用
> > 2. 内部函数：只能在所定义的 .c 中的函数中调用

## 5、预处理、动态库、静态库

### 5.1C语言编译过程

1. 预编译
   - 将 .c 中的头文件展开、宏展开
   - 生成的文件时 ==**.i**== 文件
2. 编译
   - 将预处理之后的 .i 文件生成 **==.s==** 汇编文件
3. 汇编
   - 将 .s 汇编文件生成 **==.o==** 目标文件
4. 链接
   - 将 .o 文件链接成目标文件

**Linux下的GCC编译器编译过程**

```	Linux-gcc
gcc	-E	hello.c	-o	hello.i		1、预处理

gcc	-S	hello.i	-o	hello.s		2、编译

gcc	-c	hello.s	-o	hello.o		3、汇编

gcc	hello.o	-o	hello_elf		4、链接
```

### 5.2**include**

> `#include<>`用尖括号包含头文件，在系统指定的路径下找头文件
>
> `#include" "`用双引号包含头文件，先在**当前**目录下找头文件，找不到，再到系统指定的路径下找
>
> **注意：**
>
> > include 经常用来包含头文件，可以包含 .c 文件，但尽量不要包含。因为 include 包含的文件会在预编译被展开，如果一个 .c 被包含多次，展开多次，会导致**函数重复定义**
>
> 注意：
>
> 预处理只是对 include 等预处理操作进行处理，**==不会进行语法检查==**，有错误也不会报错，第二阶段即编译阶段才进行语法检查

### 5.3**`define`**

> 定义**宏**用 **`define`** 定义
>
> **宏** 是在预编译的时候进行替换
>
> > 定义宏的好处：只要修改宏定义，其他地方在预编译的时候就会重新替换

1. 不带参宏

   ```c
   //定义宏
   //#define	英文大写	值（表达式）
   #define PI	3.14
   
   //终止宏
   #undef PI
   ```

   宏定义的作用范围：从定义的地方到本文件末尾

> **注意：**
>
> **宏定义的时候==不要加分号==**

2. 带参宏

   ```c
   //定义
   //#define	大写字母（形参）	值（表达式）
   #define		S(a,b)		a*b
   ```

   > 注意：
   >
   > 带参宏的形参没有类型名，预处理时实参代替形参，其他字符保留
   >
   > > 带参宏实在==预处理==时进行替换

3. 带参宏和带参函数的区别
   - 带参宏被调用多少次就会展开多少次，执行代码的时候没有函数调用的过程，不需要压栈弹栈。所以带参宏是浪费了空间，节省了时间
   - 带参函数，代码只有一份，存在代码段，调用的时候去代码段取指令，调用的时候需要压栈弹栈。有个调用的过程
   - 带参函数的形参是有类型的，带参宏的形参没有类型名

### 5.4选择性编译

1.**`ifdef-else-endif`**

 ```c
 #ifdef AAA	//宏
 	代码段一;
 #else
 	代码段二;
 #endif
 ```

   > 如果在当前 .c ifdef 中**定义过**AAA，就编译代码段一，否则编译代码段二
   >
   > 注意：
   >
   > > if-else 语句都会被编译，通过条件选择执行代码；而选择性编译，只有一块代码被编译

2. **`ifndef-else-endif`**

   ```c
   #ifndef	AAA
   	代码块一;
   #else
   	代码块二;
   #endif
   ```

   > 与第一种互补。经常用于防止头文件重复包含
   >
   > 如果在当前 .c ifdef 中**未定义过**AAA，就编译代码段一，否则编译代码段二

3. **`if-else-endif`**

   ```c
   #if	表达式
   	程序段一;
   #else
   	程序段二;
   #endif
   ```

   > 如果表达式为**真**，编译第一段代码，否则编译第二段代码
   >
   > **选择性编译都是在预编译阶段干的事情**

### 5.5静态库

1. 动态编译

   > **动态编译使用的是动态库文件进行编译**
   >
   > **`gcc	hello.c	-o	hello`**
   >
   > 默认使用动态编译方法

2. 静态编译

   > **静态编译使用静态库文件进行编译**
   >
   > **`gcc	-static	hello.c	-o	hello`**
   >
   > .

3. 静态编译和动态编译区别

   - 使用的库文件的格式不一样
     - 动态编译使用动态库，静态编译使用静态库

   > 注意：
   >
   > 1. 静态编译要把静态库文件打包编译到可执行文件中
   > 2. 动态编译不会把动态库文件打包编译到可执行文件中，他们只是**编译连接关系**

   **制作静态库**

   ```c
   gcc	-c	文件名.c	-o	文件名.o
   ar	rc	lib----.a	文件名.o
   ```

   > 注意：静态库起名时必须以 ==**lib**== 开头，以 ==**.a**== 结尾

   **编译方法**

   1. ```
      //编译程序命令
      gcc	-static	----.c	lib----.a	-o	----
      ```

   2. ```
      //可以指定头文件即库文件的路径，例如移动libt.a my.h 移动到 /home 下
      mv	libt.a	my.h	/home
      ```

      ```
      //编译程序命令
      gcc	-static	----.c	-o	----	-L/地址路径		-1----lib----		-I/地址路径
      ```

      > **注意：**
      >
      > 1. **-L**是指定库文件的路径
      > 2. **-1**是指定找那个库，指定的只要库文件名**lib**后面 **.a**前面的部分
      > 3. **-I**是指定头文件的路径

   3. 可以将库文件及头文件存放到系统默认指定的路径下

      - 库文件默认路径：`/lib`	或者	`/usr/lib`
      - 头文件默认路径：`/usr/include`
        - `sudo	mv	lib----.a	/usr/lib`
        
        - `sudo	mv	----.h	/usr/include`
      
      ```
      //编译程序的命令
      gcc		-static		----.c		-o		----		-1----lib----
      ```
      
      

### 5.6动态库

**制作动态链接库**

- `gcc	-shard	----lib.c	-o	lib----.so`	//使用`gcc`编译、制作动态链接库

**动态链接库的使用**

1. 库函数、头文件均在当前目录下

   ```
   gcc	----.c	lib----.so	-o	----
   export LD_LIBRARY_PATH=./:$LD_LIBRARY_PATH
   ./----
   ```

2. 库函数、头文件假设在/opt目录

   ```
   gcc	----.c	-o	----	-L/home		-1----		-I/home
   
   编译通过，运行时出错，编译时找到了库函数，但链接时找不到库，执行以下操作，把当前目录加入搜索路径
   export LD_LIBRARY_PATH=./:SLD_LIBRARY_PATH
   #./----			//可找到动态链接库
   ```

3. 库函数、头文件均在系统路径下

   ```
   cp	lib----.so	/usr/lib
   cp	----lib.h	/usr/include
   gcc		----.c		-o		----		-1----lib
   #./----
   ```

## 6、指针

### 6.1指针

#### 6.1.1关于内存

存储器：存储数据器件

> **外存**：
>
> 外存又叫外部存储器，长期存放数据，掉电不丢数据
>
> 常见的外存设备：硬盘，flash，rom，u盘，光盘，磁带
>
> **内存**:
>
> 内存又叫内部存储器，暂时存放数据，掉电丢数据
>
> 常见的内存设备：ram，DDR
>
> > 物理内存：实实在在存在的存储设备
> >
> > 虚拟内存：操作系统虚拟出来的内存
>
> **操作系统会在物理内存和虚拟内存之间做映射**
>
> 在运行程序的时候，操作系统会将 **虚拟内存** 进行分区
>
> - 堆：
>   - 在动态申请内存时，在堆里开辟内存
> - 栈:
>   - 主要存放局部变量（在函数内部，或复合语句内部定义的变量/）
> - 静态全局区：
>   - 未初始化的静态全局区
>     - 静态变量（static修饰）、未初始化的全局变量
>   - 初始化的静态全局区
>     - 赋过初值的全局变量、静态变量
> - 代码区：
>   - 存放程序代码
> - 文字常量区：
>   - 存放常量
>
> 内存以**字节**为单位来存储数据，可以将程序中的虚拟寻址空间，看成一个很大的一维的字符数组

#### 6.1.2指针的相关概念

> 系统给虚拟内存的每个存储单元分配了一个编号，从**0x00 00 00 00 ~ 0xff ff ff ff**
>
> 这个编号称为地址
>
> **指针就是地址**
>
> **指针变量：是个指针变量，即这个变量用来存放一个地址编号** 
>
> **注意：对应类型的指针变量只能存放对应类型变量的地址**，**多字节变量，编号最小的为地址**

### 6.1.3指针变量的定义方法

1. 简单的指针变量

   `数据类型	*指针变量名;	// * 用来修饰变量，说明这是个指针变量`

2. 关于指针的运算符

   **`& 取地址`、`* 取值`**

   ```c
   int a=0x1234abcd;
   int *p;
   p=&a;		//把a的地址给p赋值，取地址符&
   ```

   > p 保存了 a 的地址，也可以说是 p 指向了 a
   >
   > 如果在一行中定义多个指针变量，每一个指针变量前都要加 * 来修饰

3. 指针大小

   **32位系统下任何指针变量都占 <u>4</u> 个字节**

### 3.1.4指针的分类

1. 字符指针：字符型数据的地址

   `char *p`

2. 短整型指针

   `short int *p`

3. 整形指针

   `int *p`

   **注意：c语言规定，存储单元编号最小的那个编号，是多字节变量的地址编号**

4. 长整形指针

   `long int *p`

5. float 型指针

   `float *p`

6. double 型指针

   `double *p`

7. 函数指针

8. 结构体指针

9. 指针的指针

10. 数组指针

11. 通用指针 <u>**void***</u>

### 6.1.5指针和变量的关系

> 指针可以存放变量的地址编号
>
>  
>
> 引用变量的方法
>
> 1. 直接通过变量的名称
> 2. 可以通过指针变量来引用变量
>
> **指针就是用来存放变量的地址的**，**可以进行自加、自减操作**
>
> **注意：**
>
> 1. *p 取值取几个字节，由指针类型决定
> 2. p++ ，指向下个对应类型的数据
>    - 字符指针++，指向下个字符数据，指针存放的地址编号加1
>    - 整形指针++，指向下个整型数据，指针存放的地址编号加4

### 6.1.6指针和数组元素之间的关系

1. 指针变量可以存放数组元素的地址

2. 数组元素的引用方法

   - 数组名[下标]

     ```c
     int a[5];
     a[2]=1;
     ```

   - 指针名[下标]

     ```c
     int a[5];
     int *p;
     p=a;
     p[2]=1;
     ```

   - 通过指针变量运算+取值的方法来引用数组的元素

     ```c
     int a[5];
     int *p;
     p=a;
     *(p+2)=1;	//相当于a[2]=1
     ```

     **解释：p是第0个元素的地址，p+2 相当于 a[2] 这个元素的地址**

   - 通过数组名+取值的方法引用数组元素

     ```c
     int a[5];
     *(a+2)=1;	//相当于a[2]=1
     ```

     

   - **c语言规定：数组的名字就是数组的首地址，即第0个元素的地址，是个常量**

3. 指针的运算

   1. 指针可以加一个整数，表示往后几个它指向的变量，结果仍是地址（**前提：指针指向数组时**）
   2. 两个相同类型指针可以比较大小
      - 前提：<u>只有两个相同类型的指针指向同一个数组的元素的时候</u>，比较大小才有意义。且**指向前面元素的指针 <u>小于</u> 指向后面元素的指针**
   3. 两个相同类型的指针可以做减法
      - 前提：<u>只有两个相同类型的指针指向同一个数组的元素的时候</u>，做减法才有意义。做减法的结果是**两个指针指向的中间有多少个元素**
   4. 两个相同类型的指针可以相互赋值
      - 注意：只有相同类型的指针才可以相互赋值（void * 类型除外），如果类型不相同的指针要想相互赋值，必须进行强制类型转换

### 6.1.7指针数组

**指针数组的概念：指针数组是个数组，是个指针数组，是若干个相同类型的指针变量构成的集合**

1. 指针和数组的关系

   - 1. 指针可以保存数组元素的地址
     2. 可以定义一个有若干个相同类型的指针变量，称为指针数组

2. 指针数组的定义方法
   ```c
   //类型说明符 *数组名[元素个数]
   int *p[5]			//定义了一个整型的指针数组p，由5个元素p[0]~p[4]
   ```

3. 指针数组的分类

   | 类型 | 名称 |
   |:----:|:---:|
   | 字符型指针数组 |  |
   | 短整型指针数组 | |
   | 整形指针数组 | |
   | 长整型指针数组 | |
   | float型指针数组 | |
   | double型指针数组 | |
   | 结构体指针数组 | |
   | 函数指针数组 | |
   

### 6.1.8指针的指针

指针的指针：即指针的地址


## 7、动态内存申请

### 7.1





 
