

# Linux 命令

`echo $SHELL` 命令可以查看当前使用的 shell。

[Linux 命令基础入门_Linux - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/courses/68)

## 每天一个`Linux` 命令

[每天一个`linux`命令目录 - `peida` - 博客园 (cnblogs.com)](https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html)



## 到底什么是命令？

命令可以是下面四种形式之一：

1. 是一个可执行程序，就像我们所看到的位于目录`/usr/bin`中的文件一样。属于这一类的程序，可以编译成二进制文件，诸如用 `C` 和 `C++` 语言写成的程序，也可以是由脚本语言写成的程序，比如说 `shell`，`perl`，`python`，`ruby`，等等。
2. 是一个内建于 `shell` 自身的命令。`bash` 支持若干命令，内部叫做 `shell` 内部命令 (`builtins`)。例如，上面我本地环境中的 `cd` 命令，就是一个 `shell` 内部命令。
3. 是一个 `shell `函数。这些是小规模的 `shell` 脚本，它们混合到环境变量中。 比如上面讲到的 `cd` 命令，在某些环境中就是一个 `shell` 函数。
4. 是一个命令别名。我们可以定义自己的命令，建立在其它命令之上。

## `ls` 打印目录清单

`ls` 命令是 linux 下最常用的命令，`ls `命令就是` list` 的缩写。` ls `用来打印出当前目录的清单。如果 `ls` 指定其他目录，那么就会显示指定目录里的文件及文件夹清单。 通过 `ls `命令不仅可以查看 linux 文件夹包含的文件，而且还可以查看目录和文件权限等等信息。

**命令格式**

> `ls` [选项] [目录名]

**常用参数**

| 参数 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| -a   | –all 列出目录下的所有文件，包括以 . 开头的隐含文件           |
| -l   | 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 |
| -h   | –human-readable 以容易理解的格式列出文件大小（例如 1K 234M 2G) |
| -t   | 以文件修改时间排序                                           |



## `cd` 切换当前目录至指定目录

`cd` 命令可以说是 Linux 中最基本的命令语句，其他的命令语句要进行操作，都是建立在使用 `cd` 命令上的。`cd` 命令是 `change directory` 的缩写，切换当前目录至指定的目录。

**命令格式**

> `cd` [目录名]

- 从当前目录进入系统根目录

  ```shell
  cd  /

- 从当前目录进入父目录

  ```shell
  cd ..
  ```

- 从当前目录进入当前用户的主目录

  ```shell
  cd ~
  ```

- 从当前目录进入上次所在目录

  ```shell
  cd -
  ```

  

## `pwd` 确认当前目录在文件系统内的确切位置



Linux 中用 `pwd` 命令来查看“当前工作目录”的完整路径。简单的说，每当你在终端进行操作时，你都会有一个当前工作目录。在不太确定当前位置时，就可以使用 `pwd` 来判定当前目录在文件系统内的确切位置。 `pwd ` 命令是 `Print Working Directory `的缩写。

**命令格式**

> `pwd` [选项]

**常用参数**

| 参数 | 描述                                       |
| ---- | ------------------------------------------ |
| -P   | 显示实际物理路径，而非使用连接（link）路径 |
| -L   | 当目录为连接路径时，显示连接路径           |

- 显示当前目录所在路径

  ```shell
  pwd
  ```

- 显示当前目录的物理路径（大写）

  ```shell
  pwd -P
  ```

- 显示当前目录的连接路径（大写）

  ```shell
  pwd -L
  ```



## `rm` 删除文件或目录或子文件、子目录的一个或多个

`rm` 是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只会删除链接，原文件均保持不变。

`rm` 是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行 `rm * -rf`）。所以，我们在执行 rm 之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。

`rm` 命令是 `remove `的缩写。

**命令格式**

> `rm` [选项] 文件或目录

**常用参数**

| 参数             | 描述                                               |
| ---------------- | -------------------------------------------------- |
| -f --force       | 忽略不存在的文件，从不给出提示                     |
| -i --interactive | 进行交互式删除                                     |
| -r --recursive   | 指示 rm 将参数中列出的全部目录和子目录均递归地删除 |
| -v --verbose     | 详细显示进行的步骤                                 |



## `mv` 移动文件或更改文件名

`mv` 命令功能是用来移动文件或更改文件名，是 Linux 系统下常用的命令，经常用来备份文件或者目录。 `mv` 命令根据第二个参数类型（目标是一个文件还是目录），决定执行将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，`mv` 命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，`mv` 命令将各参数指定的源文件均移至目标目录中。 `mv` 命令是 `move` 的缩写。

**命令格式**

> `mv` [选项] 源文件或目录 目标文件或目录

**常用参数**

| 参数                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| -b --back             | 若需覆盖文件，则覆盖前先行备份                               |
| -f --force            | 如果目标文件已经存在，不会询问而直接覆盖                     |
| -i <br/>--interactive | 若目标文件已经存在时，就会询问是否覆盖                       |
| -u --update           | 若目标文件已经存在，且源文件比较新，才会更新                 |
| -t --target           | 该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后 |



## `cp` 复制文件或目录

`cp` 命令用来复制文件或者目录，是 Linux 系统中最常用的命令之一。一般情况下，`shell` 会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用` -i` 参数。但是如果是在 `shell` 脚本中执行 `cp` 时，没有` -i `参数时不会询问是否覆盖。这说明命令行和 `shel`l 脚本的执行方式有些不同。 `cp` 命令是 `copy` 的缩写。

**命令格式**

> `cp` [选项] 源文件 目录 
>
> `cp` [选项] `-t` 目录 源文件

**常用参数**

| 参数                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| -t --target-directory | 指定目标目录                                                 |
| -i --interactive      | 覆盖前询问（使前面的 -n 选项失效）                           |
| -n --no-clobber       | 不要覆盖已存在的文件（使前面的 -i 选项失效）                 |
| -s --symbolic-link    | 对源文件建立符号链接，而非复制文件                           |
| -f --force            | 强行复制文件或目录，不论目的文件或目录是否已经存在           |
| -u --update           | 使用这项参数之后，只会在源文件的修改时间较目的文件更新时，或是对应的目的文件并不存在，才复制文件 |



## `cat` 将文件或标准输入组合输出到标准输出

`cat `命令的功能是将文件或标准输入组合输出到标准输出。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 `cat` 命令是 `concatenate` 的缩写。

说明：`tac` 是将 `cat` 反写过来，所以它的功能就跟 `cat` 相反，`cat` 是由第一行开始到最后一行连续显示在屏幕上，而 `tac` 则是由最后一行开始到第一行反向在屏幕上显示出来。

**命令格式**

> `cat` [选项] [文件]

**常用参数**

| 参数                  | 描述                                              |
| --------------------- | ------------------------------------------------- |
| -A --show-all         | 等价于 -vET                                       |
| -b --number-nonblank  | 对非空输出行编号                                  |
| -e                    | 等价于 -vE                                        |
| -E --show-ends        | 在每行结束处显示 $                                |
| -n --number           | 对输出的所有行编号，由 1 开始对所有输出的行数编号 |
| -s --squeeze-blank    | 有连续两行以上的空白行，就代换为一行的空白行      |
| -t                    | 与 -vT 等价                                       |
| -T --show-tabs        | 将跳格字符显示为 ^I                               |
| -u                    | （被忽略）                                        |
| -v --show-nonprinting | 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外           |



## `nl` 计算文件中的行号

`nl `命令在 `linux` 系统中用来计算文件中的行号。`nl` 可以将输出的文件内容自动加上行号，其默认的结果与 `cat -n` 有点不太一样。 `nl` 可以将行号做较多的显示设计，包括位数与是否自动补齐 0 等等的功能。
`nl` 命令是 `number of lines` 的缩写。

**命令格式**

> `nl` [选项] [文件]

**常用参数**

| 参数  | 描述                                              |
| ----- | ------------------------------------------------- |
| -b    | 指定行号指定的方式，主要有两种：                  |
| -b a  | 表示不论是否为空行，也同样列出行号（类似 cat -n） |
| -b t  | 如果有空行，空的那一行不要列出行号（默认值）      |
| -n    | 列出行号表示的方法，主要有三种：                  |
| -n ln | 行号在屏幕的最左方显示                            |
| -n rn | 行号在自己栏位的最右方显示，且不加 0              |
| -n rz | 行号在自己栏位的最右方显示，且加 0                |
| -w    | 行号栏位的占用的位数                              |



## `more`

`more` 命令，功能类似 `cat` ，`cat` 命令是将整个文件的内容从上到下显示在屏幕上。 `more` 命令会一页一页的显示，方便使用者逐页阅读，而最基本的指令就是按空格键（`space`）往下一页显示，按 `B `键就会往回（`back`）一页显示，而且还有搜寻字串的功能。`more` 命令从前向后读取文件，因此在启动时就加载整个文件。

**命令格式**

> `more` [选项] 文件

**常用参数**

| 参数      | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| +n        | 从笫 n 行开始显示                                            |
| -n        | 定义屏幕大小为 n 行                                          |
| +/pattern | 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 |
| -c        | 从顶部清屏，然后显示                                         |
| -d        | 提示“Press space to continue，’q’ to quiet”，禁用响铃功能    |
| -p        | 通过清除窗口而不是滚屏来对文件进行换页，与-c 选项相似        |
| -s        | 把连续的多个空行显示为一行                                   |
| -u        | 把文件内容中的下划线去掉                                     |

**常用操作**

| 符号   | 描述             |
| ------ | ---------------- |
| =      | 输出当前行的行号 |
| q      | 退出 more        |
| 空格键 | 向下滚动一屏     |
| b      | 返回上一屏       |



## `less`

`less` 命令也是对文件或其它输出进行分页显示的工具，应该说是 `linux` 正统查看文件内容的工具，功能极其强大。

**命令格式**

> `less` [选项] 文件

**常用参数**

| 参数 | 描述                                                 |
| ---- | ---------------------------------------------------- |
| -e   | 当文件显示结束后，自动离开                           |
| -f   | 强迫打开特殊文件，例如外围设备代号、目录和二进制文件 |
| -i   | 忽略搜索时的大小写                                   |
| -m   | 显示类似 more 命令的百分比                           |
| -N   | 显示每行的行号                                       |
| -s   | 显示连续空行为一行                                   |

**常用操作**

| 符号    | 描述                                 |
| ------- | ------------------------------------ |
| /字符串 | 向下搜索“字符串”的功能               |
| ?字符串 | 向上搜索“字符串”的功能               |
| n       | 重复前一个搜索（与 / 或 ? 有关）     |
| N       | 反向重复前一个搜索（与 / 或 ? 有关） |
| b       | 向前翻一页                           |
| d       | 向后翻半页                           |
| q       | 退出 less 命令                       |
| 空格键  | 向后翻一页                           |
| 向上键  | 向上翻动一行                         |
| 向下键  | 向下翻动一行                         |



## `less` 与 `cat` 与 `more` 区别

`cat` 命令功能：用于显示整个文件的内容，因为单独使用没有翻页功能，所以经常和 `more` 命令搭配使用，`cat` 命令还有一个可以将数个文件合并成一个文件的功能。

`more` 命令功能：让画面在显示满一页时暂停，此时可按空格健继续显示下一个画面，或按 `q` 键停止显示。

`less` 命令功能：`less` 命令的用法与 `more` 命令类似，也可以用来浏览超过一页的文件。所不同的是 `less` 命令除了可以按空格键向下显示文件外，还可以利用上下键来滚动文件。当要结束浏览时，只要在 `less` 命令的提示符“`：`”下按 `q` 键即可。

**其实这三个命令除了 `cat` 命令有合并文件的功能外，其余功能都很相近，只是在浏览习惯和显示方式上有所不同。**



## `head`

`head` 命令就像它的名字一样浅显易懂，主要是用来显示档案的开头至标准输出中，默认` head` 命令打印其相应文件的开头 **`10`** 行。

**命令格式**

> `head` [选项] [文件]

**常用参数**

| 参数     | 描述       |
| -------- | ---------- |
| -q       | 隐藏文件名 |
| -v       | 显示文件名 |
| -c<字节> | 显示字节数 |
| -n<行数> | 显示的行数 |



## `tail`

`tail` 命令主要用于显示指定文件末尾内容。常用查看日志文件。

**命令格式**

> `tail` [选项] [文件]

**常用参数**

| 参数     | 描述               |
| -------- | ------------------ |
| -f       | 循环读取           |
| -q       | 不显示处理信息     |
| -v       | 显示详细的处理信息 |
| -c<字节> | 显示的字节数       |
| -n<行数> | 显示行数           |

使用 `tail` 命令的` -f `选项可以即时输出文件变化后追加的内容。`tail -f filename` 会把 `filename` 里最尾部的内容显示在屏幕上，并且不断刷新，使你看到最新的文件内容。 另外顺便说一下怎么查看后台正在运行的任务及怎么停止任务。 `jobs` 命令可以查看正在后台运行的任务。`kill` 命令可以杀死一个任务，但要使用任务的 `pid`。任务的 `pid` 可以通过 `ps` 命令查看获得，然后使用`kill -9 任务pid`就可以将这个后台进程杀死。



## `which`

`which` 命令的作用是，在 `PATH` 变量指定的路径中搜索可执行文件的所在位置。它一般用来确认系统中是否安装了指定的软件。

**命令格式**

> `which` 可执行文件名称



## `whereis`

`whereis` 命令主要用于定位可执行文件、源代码文件和帮助文件在文件系统中的位置。`whereis` 命令还具有搜索源代码、指定备用搜索路径和搜索不寻常项的功能。

`whereis` 命令查找速度非常快，这是因为它根本不是在磁盘中漫无目的乱找，而是在一个数据库中（`/var/lib/mlocate/mlocate.db`）查询。这个数据库是 `Linux` 系统自动创建的，包含有本地所有文件的信息，并且每天通过自动执行 `updatedb` 命令更新一次。也正是因为这个数据库要每天才更新一次，就会使得 `whereis` 命令的搜索结果有时候会不准确，比如刚添加的文件可能搜不到。

**命令格式**

> `whereis` [选项] 文件

**常用参数**

| 参数 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| -b   | 定位可执行文件                                               |
| -m   | 定位帮助文件                                                 |
| -s   | 定位源代码文件                                               |
| -u   | 搜索默认路径下除可执行文件、源代码文件和帮助文件以外的其它文件 |
| -B   | 指定搜索可执行文件的路径                                     |
| -M   | 指定搜索帮助文件的路径                                       |
| -S   | 指定搜索源代码文件的路径                                     |



## `locate`

`locate` 命令跟` whereis` 命令类似，且它们使用的是相同的数据库。但 `whereis` 命令只能搜索可执行文件、联机帮助文件和源代码文件，如果要获得更全面的搜索结果，可以使用 `locate` 命令。

`locate` 命令使用了十分复杂的匹配语法，可以使用特殊字元（如’`*`’和’`?`’）来指定需要查找的样本。

**命令格式**

> `locate` [选项] [搜索字符串]

**常用参数**

| 参数 | 描述                           |
| ---- | ------------------------------ |
| -q   | 安静模式，不会显示任何错误讯息 |
| -n   | 至多显示 n 个输出              |
| -r   | 使用正则表达式做寻找的条件     |
| -V   | 显示版本信息                   |



## `find`

`find` 命令主要作用是沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应的操作。`Linux` 下 `find` 命令提供了相当多的查找条件，功能很强大，对应的学习难度也比较大。

**命令格式**

> `find` [选项] [搜索路径] [表达式]

默认路径是当前目录，默认表达式为` -print`。

表达式可能由下列成份组成：操作符、选项、测试表达式以及动作。

**常用参数**

| 参数         | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| -print       | find 命令将匹配的文件输出到标准输出                          |
| -exec        | find 命令对匹配的文件执行该参数所给出的 shell 命令           |
| -name        | 按照文件名查找文件                                           |
| -type        | 查找某一类型的文件                                           |
| -prune       | 使用这一选项可以使 find 命令不在当前指定的目录中查找，如果同时使用 -depth 选项，那么 -prune 将被 find 命令忽略 |
| -user        | 按照文件属主来查找文件                                       |
| -group       | 按照文件所属的组来查找文件                                   |
| -mtime -n +n | 按照文件的更改时间来查找文件，-n 表示文件更改时间距现在小于 n 天，+n 表示文件更改时间距现在大于 n 天，find 命令还有 -atime 和 -ctime 选项 |

其他命令选项及表达式可参见下图。

![](https://doc.shiyanlou.com/userid3372labid348time1419485012419)

下面介绍如何根据文件类型、权限、所有者及操作符来查找匹配文件。

根据文件类型来查找文件，使用 `-type` 选项，常见 `find` 文件类型见下表：

![img](https://doc.shiyanlou.com/userid3372labid348time1419485465186)

根据文件权限查找文件，使用 `-perm` 选项。所有者使用 `-user` 选项。

另外，`find` 命令可以通过逻辑操作符来创建更复杂的逻辑关系。`find` 命令的逻辑操作符见下表：

![img](https://doc.shiyanlou.com/userid3372labid348time1419485513603)

如何使用 `find` 命令的 `-exec` 选项来实现对查找到的文件执行指定的动作命令。

`exec` 是 `find` 命令对找到的文件执行的动作，这个动作就是对找到的文件执行命令，上面的命令就是`ls -l {}`。在这里说明一下`{}`和`\;`，`{}`其实它就是一个占位符，在 find 命令的执行过程中会不断地替换成当前找到的文件，相当于”`ls -l` 找到的文件”。而`\;`是 `-exec` 命令结束的标记，因为规定 `-exec` 后面的命令必须以`;`结束，但`;`在 `shell` 中有特殊含义，必须要转义，所以写成`\;`。



## `xargs`

我们可以用管道将一个命令的 `stdout`（标准输出）重定向到另一个命令的 `stdin`（标准输入）。但有些命令只能以命令行参数的形式接收数据，而无法通过 `stdin` 接收数据流。在这种情况下，无法通过管道将数据重定向给这些命令。

这时 `xargs` 就可以发挥它的作用了，`xargs` 命令可以从标准输入接收输入，并把输入转换为一个特定的参数列表。

**命令格式**

> `command | xargs` [选项] [command]

`xargs` 命令应该紧跟在管道操作符之后，因为它以标准输入作为主要的源数据流。

**常用参数**

| 参数 | 描述                   |
| ---- | ---------------------- |
| -n   | 指定每行最大的参数数量 |
| -d   | 指定分隔符             |



## `wc`

`wc` 命令是一个统计的工具，主要用来显示文件所包含的行、字和字节数。

`wc` 命令是 `word count` 的缩写。

**命令格式**

> `wc` [选项] [文件]

**常用参数**

| 参数 | 描述                                                       |
| ---- | ---------------------------------------------------------- |
| -c   | 统计字节数                                                 |
| -l   | 统计行数                                                   |
| -m   | 统计字符数，这个标志不能与 -c 标志一起使用                 |
| -w   | 统计字数，一个字被定义为由空白、跳格或换行字符分隔的字符串 |
| -L   | 打印最长行的长度                                           |



## `grep`

`grep` 是个很强大的命令，用来找到文件中的匹配文本，并且能够接受正则表达式和通配符，同时可以用多个 `grep` 命令选项来生成各种格式的输出。

`grep` 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。

`grep` 可用于 `shell` 脚本，因为 `grep` 通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回 0，如果搜索不成功，则返回 1，如果搜索的文件不存在，则返回 2。我们利用这些返回值就可进行一些自动化的文本处理工作。

**命令格式**

> `grep` [选项] `pattern` [file]

**常用参数**

| 参数         | 描述                                     |
| ------------ | ---------------------------------------- |
| -c           | 计算找到‘搜寻字符串’（即 pattern）的次数 |
| -i           | 忽略大小写的不同，所以大小写视为相同     |
| -n           | 输出行号                                 |
| -v           | 反向选择，打印不匹配的行                 |
| -r           | 递归搜索                                 |
| --color=auto | 将找到的关键词部分加上颜色显示           |



## 正则表达式与 `grep` 命令

正则表达式是一种符号表示法，被用来识别文本模式。在某种程度上，它们与匹配文件和路径名的 `shell` 通配符比较相似，但其规模更大。许多命令行工具和大多数的编程语言都支持正则表达式，以此来帮助解决文本操作问题。

正则表达式元字符由以下字符组成：

> - ^
>
> - $
> - .
> - [ ]
> - { }
> - -
> - ?
> - *
> - +
> - ( )
> - |
> - \

![img](https://doc.shiyanlou.com/userid3372labid353time1419920809160)

## `cut`

`cut` 命令是一个将文本按列进行切分的小工具，它可以指定分隔每列的定界符。

如果一行数据包含多个字段（多列），现在想要提取其中的一列或多列，这时 `cut` 命令就可以大显身手了。

**命令格式**

> `cut` [选项] [文件名]

**常用参数**

| 参数         | 描述                                               |
| ------------ | -------------------------------------------------- |
| -b           | 以字节为单位进行分割                               |
| -c           | 以字符为单位进行分割                               |
| -d           | 自定义分隔符，默认为制表符                         |
| -f           | 自定义字段                                         |
| --complement | 抽取整个文本行，除了那些由 -c 或 -f 选项指定的文本 |



## `paste`

`paste` 命令的功能正好与 `cut` 相反。它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列。它通过读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准输出。

**命令格式**

> `paste` [选项] [文件名]

**常用参数**

| 参数 | 描述                             |
| ---- | -------------------------------- |
| -s   | 将每个文件合并成行而不是按行粘贴 |
| -d   | 自定义分隔符，默认为制表符       |



## `tr`

`tr` 命令常被用来更改字符，我们可以把它看作是一种基于字符的查找和替换操作。换字是一种把字符从一个字母转换为另一个字母的过程，`tr` 可以从标准输入中替换、缩减和删除字符，并将结果写到标准输出。

`tr` 只能通过 `stdin`（标准输入），而无法通过命令行参数来接受输入。

`tr` 是 `translate`（转换）的缩写。

**命令格式**

> `tr` [选项] `SET1` `SET2`

将来自 `stdin` 的输入字符从` SET1` 映射到 `SET2`，并将其输出写入 `stdout`（标准输出）。`SET1` 和 `SET2` 是字符类或字符集。如果两个字符集的长度不相等，那么 `SET2` 会不断重复其最后一个字符，直到长度与 `SET1` 相同。如果 `SET2` 的长度大于 `SET1`，那么在 `SET2` 中超出 `SET1` 的那部分字符则全部被忽略。

**常用参数**

| 参数 | 描述                             |
| ---- | -------------------------------- |
| -d   | 删除匹配 SET1 的内容，并不作替换 |



## `sort`

同文本文件打交道时，总避不开排序，那是因为对于文本处理任务而言，排序（sort）可以起到不小的作用。sort 命令能够帮助我们对文本文件和 stdin 进行排序操作。通常，它会结合其他命令来生成所需要的输出。

**命令格式**

> `sort` [选项] [文件名]

**常用参数**

| 参数 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| -n   | 基于字符串的长度来排序，使用此选项允许根据数字值排序，而不是字母值 |
| -k   | 指定排序关键字                                               |
| -b   | 默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项导致 sort 程序忽略每行开头的空格，从第一个非空白字符开始排序 |
| -m   | 只合并多个输入文件                                           |
| -r   | 按相反顺序排序，结果按照降序排列，而不是升序                 |
| -t   | 自定义分隔符，默认为制表符                                   |



-k 选项的语法格式如下：

```
[ FStart [ .CStart ] ] [ Modifier ] [ , [ FEnd [ .CEnd ] ][ Modifier ] ]
```

这个语法格式可以被其中的逗号（“，”）分为两大部分，`Start` 部分和 `End` 部分。

先给你灌输一个思想，那就是“如果不设定 `End` 部分，那么就认为 `End` 被设定为行尾”。这个概念很重要的，但往往你不会重视它。

`Start` 部分也由三部分组成，其中的 `Modifier` 部分就是类似 `n` 和 `r` 的选项部分。我们重点说说 `Start` 部分的 `FStart` 和` CStart`。 `FStart.CStart`，其中 `FStart` 就是表示使用的域，而 `CStart` 则表示在 `FStart` 域中从第几个字符开始算“排序首字符”。`CStart` 是可以省略的，省略的话就表示从本域的开头部分开始。例二中的 `-k 5` 就是省略了 `CStart` 的例子。

同理，在 `End` 部分中，你可以设定 `FEnd.CEnd`，如果你省略`.CEnd`，则表示结尾到“域尾”，即本域的最后一个字符。或者，如果你将 `CEnd` 设定为 0(零)，也是表示结尾到“域尾”。



## `uniq`

`uniq` 命令经常和 `sort` 命令结合在一起使用。`uniq` 从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除任何重复行。

`uniq` 只能用于排过序的数据输入，因此，`uniq` 要么使用管道，要么将排过序的文件作为输入，并总是以这种方式与 `sort` 命令结合起来使用。

`uniq` 命令是 `unique` 的缩写。

**命令格式**

> `uniq` [选项] [文件名]

**常用参数**

| 参数 | 描述                                       |
| ---- | ------------------------------------------ |
| -c   | 在每行前加上表示相应行目出现次数的前缀编号 |
| -d   | 只输出重复的行                             |
| -u   | 只显示唯一的行                             |
| -D   | 显示所有重复的行                           |
| -f   | 比较时跳过前 n 列                          |
| -i   | 在比较的时候不区分大小写                   |
| -s   | 比较时跳过前 n 个字符                      |
| -w   | 对每行第 n 个字符以后的内容不作对照        |



## `join`

`join` 命令类似于` paste`，它会往文件中添加列，但是它使用了独特的方法来完成。一个 `join` 操作通常与关系型数据库有关联，在关系型数据库中来自多个享有共同关键域的表格的数据结合起来，得到一个期望的结果。这个 `join` 命令执行相同的操作，它把来自于多个基于共享关键域的文件的数据结合起来。

通俗地说，就是将两个文件中指定栏位相同的行连接起来，即按照两个文件中共同拥有的某一列，将对应的行拼接成一行。

**命令格式**

> `join` [选项] 文件 1 文件 2

**常用参数**

| 参数     | 描述                                                |
| -------- | --------------------------------------------------- |
| -j FIELD | 等同于 -1 FIELD -2 FIELD，-j 指定一个域作为匹配字段 |
| -1 FIELD | 以 file1 中 FIELD 字段进行匹配                      |
| -2 FIELD | 以 file2 中 FIELD 字段进行匹配                      |
| -t       | 自定义分隔符，默认为制表符                          |



## `comm`

通常 `comm` 命令对比较文本文件的内容很有帮助。对于系统管理员和软件开发者来说，这个命令尤为重要。例如，一名系统管理员需要拿现有的配置文件与先前的版本做比较，来诊断一个系统错误。同样的，一名程序员经常需要查看程序的修改内容。

`comm` 命令将逐行比较已经排序的两个文件。显示结果包括 3 列：第 1 列为只在第一个文件中找到的行，第 2 列为只在第二个文件中找到的行，第 3 列为两个文件的共有行。

注意，`comm` 命令和 `join`、`uniq` 命令一样，只能用于已经排过序的数据。

**命令格式**

> `comm` [选项] 文件 1 文件 2

**常用参数**

| 参数 | 描述                   |
| ---- | ---------------------- |
| -1   | 不输出文件 1 特有的行  |
| -2   | 不输出文件 2 特有的行  |
| -3   | 不输出两个文件共有的行 |



## `diff`

类似 `comm` 命令，`diff` 命令被用来监测文件之间的差异。然而，`diff` 是一款更加复杂的工具，它支持许多输出格式，并且一次能处理许多文本文件。软件开发员经常使用 `diff` 程序来检查不同程序源码版本之间的更改，`diff` 能够递归地检查源码目录，通常称之为源码树。`diff` 程序的一个常见用例是创建 `diff` 文件或者补丁，它会被其它程序使用，例如 `patch` 程序（我们后面会讲到），来把文件从一个版本转换为另一个版本。

`diff` 在命令行中打印每一行的改动，并且 `diff` 是` svn`、`cvs`、`git` 等版本控制工具不可或缺的一部分。

`diff` 命令是 `differential` 的缩写。

**命令格式**

> `diff` [选项] 文件

**常用参数**

| 参数 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| -c   | 上下文模式，显示全部内文，并标出不同之处                     |
| -u   | 统一模式，以合并的方式来显示文件内容的不同                   |
| -a   | 只会逐行比较文本文件                                         |
| -N   | 在比较目录时，若文件 A 仅出现在某个目录中，预设会显示：Only in 目录。若使用 -N 参数，则 diff 会将文件 A 与一个空白的文件比较 |
| -r   | 递归比较目录下的文件                                         |

**`diff` 的` normal `显示格式有三种提示:**

- `a - add`
- `c - change`
- `d - delete`

**三种特殊字符：**

- **`+`** 添加行，这一行将会出现在第二个文件内，而不是第一个文件内 
- **`-`** 删除行，这一行将会出现在第一个文件中，而不是第二个文件内 
- **`!`** 更改行，将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分

**特殊字符：**

- ＋ 添加这一行到第一个文件中
- － 在第一个文件中删除这一行



## `patch`

`patch` 命令被用来把更改应用到文本文件中。它接受从 `diff` 程序的输出，并且通常被用来把较老的文件版本转变为较新的文件版本。让我们看看一个著名的例子：`Linux` 内核是由一个大型的，组织松散的贡献者团队开发而成，这些贡献者会提交固定的少量更改到源码包中。这个` Linux` 内核由几百万行代码组成，虽然每个贡献者每次所做的修改相当少。对于一个贡献者来说，每做一个修改就给每个开发者发送整个的内核源码树，这是没有任何意义的。这时我们可以提交一个 `diff` 文件。一个 `diff` 文件包含先前的内核版本与带有贡献者修改的新版本之间的差异。然后一个接受者使用 `patch` 程序，把这些更改应用到他自己的源码树中。使用 `diff/patch` 组合提供了两个重大优点：

1. 与整个源码树的大小相比较而言，一个 `diff` 文件非常小。
2. 一个 `diff` 文件简洁地显示了所做的修改，从而允许程序补丁的审阅者能快速地评估它。

当然，`diff/patch` 能工作于任何文本文件，不仅仅是源码文件。它同样适用于配置文件或任意其它文本。

准备一个 `diff` 文件供 `patch` 命令使用，`GNU` 文档建议这样使用 `diff` 命令：

```
diff -Naur old_file new_file > diff_file
```

`old file` 和 `new file` 部分不是单个文件就是包含文件的目录。这个 `r` 选项支持递归目录树。

**命令格式**

> `patch` [选项] 补丁文件

**常用参数**

| 参数   | 描述                           |
| ------ | ------------------------------ |
| -p num | 忽略几层文件夹                 |
| -E     | 如果发现了空文件，那么就删除它 |
| -R     | 取消打过的补丁                 |



## `df`

`linux` 中 `df` 命令的功能是用来检查 `linux` 服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。

`df` 命令是 `disk free` 的缩写。

**命令格式**

> `df` [选项] 文件

**常用参数**

| 参数             | 描述                         |
| ---------------- | ---------------------------- |
| -a               | 全部文件系统列表             |
| -h               | 方便阅读方式显示             |
| -i               | 显示 inode 信息              |
| -T               | 文件系统类型                 |
| -t<文件系统类型> | 只显示选定文件系统的磁盘信息 |
| -x<文件系统类型> | 不显示选定文件系统的磁盘信息 |



## `du`

`linux` 中 `du` 命令也是查看使用空间的，但是与 `df` 命令不同的是 `Linux du` 命令是对文件和目录磁盘使用的空间的查看。

`du` 命令是 `disk usage` 的缩写。

**命令格式**

> `du` [选项] 文件

**常用参数**

| 参数 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| -a   | 显示目录中所有文件的大小。                                   |
| -b   | 显示目录或文件大小时，以 byte 为单位。                       |
| -c   | 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。 |
| -k   | 以 KB(1024bytes)为单位输出。                                 |
| -m   | 以 MB 为单位输出。                                           |
| -s   | 仅显示总计，只列出最后加总的值。                             |
| -h   | 以 K，M，G 为单位，提高信息的可读性。                        |



## `time`

`time` 命令常用于测量一个命令的运行时间，包括实际使用时间（`real time`）、用户态使用时间（`the process spent in user mode`）、内核态使用时间（`the process spent in kernel mode`）。

实际时间: 从 `command` 命令行开始执行到运行终止的时间。

用户态使用时间：命令执行完成花费的用户 `CPU `时间，即命令在用户态中执行时间总和。 内核态使用时间：命令执行完成花费的系统 `CPU` 时间，即命令在核心态中执行时间总和。

**命令格式**

> `time` 命令

`time` 是 `shell` 的关键字，`shell` 做了特殊处理，它会把` time` 命令后面的命令行作为一个整体来进行处理，在重定向时，实际上是针对后面的命令来的，`time` 命令本身的输出并不会被重定向的。比如，执行`time date 2>3.txt`，`3.txt` 的内容为空。另外，`time` 命令的输出信息是打印在标准错误输出上的。







































































# Linux基础

## Linux目录操作

![](https://doc.shiyanlou.com/courses/uid8504-20190517-1558079206858)

![](https://doc.shiyanlou.com/courses/uid8504-20191220-1576838774210)

![](https://doc.shiyanlou.com/linux_base/1-8.png)

![](https://doc.shiyanlou.com/linux_base/2-1.png)





| 按键            | 作用                                         |
| --------------- | -------------------------------------------- |
| `Ctrl+d`        | 键盘输入结束或退出终端                       |
| `Ctrl+s`        | 暂停当前程序，暂停后按下任意键恢复运行       |
| `Ctrl+z`        | 将当前程序放到后台运行，恢复到前台为命令`fg` |
| `Ctrl+a`        | 将光标移至输入行头，相当于`Home`键           |
| `Ctrl+e`        | 将光标移至输入行末，相当于`End`键            |
| `Ctrl+k`        | 删除从光标所在位置到行末                     |
| `Alt+Backspace` | 向前删除一个单词                             |
| `Shift+PgUp`    | 将终端显示向上滚动                           |
| `Shift+PgDn`    | 将终端显示向下滚动                           |



| 字符                    | 含义                                       |
| ----------------------- | ------------------------------------------ |
| `*`                     | 匹配 0 或多个字符                          |
| `?`                     | 匹配任意一个字符                           |
| `[list]`                | 匹配 list 中的任意单一字符                 |
| `[^list]`               | 匹配 除 list 中的任意单一字符以外的字符    |
| `[c1-c2]`               | 匹配 c1-c2 中的任意单一字符 如：[0-9][a-z] |
| `{string1,string2,...}` | 匹配 string1 或 string2 (或更多)其一字符串 |
| `{c1..c2}`              | 匹配 c1-c2 中全部字符 如{1..10}            |



通常情况下，man 手册里面的内容都是英文的，这就要求你有一定的英文基础。man 手册的内容很多，涉及了 Linux 使用过程中的方方面面。为了便于查找，man 手册被进行了分册（分区段）处理，在 Research UNIX、BSD、OS X 和 Linux 中，手册通常被分为 8 个区段，安排如下：

| 区段 | 说明                                      |
| ---- | ----------------------------------------- |
| 1    | 一般命令                                  |
| 2    | 系统调用                                  |
| 3    | 库函数，涵盖了 C 标准函数库               |
| 4    | 特殊文件（通常是/dev 中的设备）和驱动程序 |
| 5    | 文件格式和约定                            |
| 6    | 游戏和屏保                                |
| 7    | 杂项                                      |
| 8    | 系统管理命令和守护进程                    |

要查看相应区段的内容，就在 man 后面加上相应区段的数字即可





### 查看当前目录`pwd`

### 查看目录中的内容`ls`

### 进入目录`cd`

#### 快捷操作

```
cd ..	/回到上一级目录
cd -	/回到上一次所在的目录
cd ~	/回到当前用户的主目录
cd /	/进入根目录，它是一切目录的父目录

```



### **查看目录结构`tree`**

```
$ cd /
$ tree
执行两次操作，遍历系统中所有的目录和文件，按下 ctrl + c 停止
```



### 新建目录`mkdir`

**还可以在 `mkdir` 后加入 `-p` 参数，一次性创建多级目录**





## Linux文件操作

### 新建空白文件`touch`

### 复制`cp`

- **使用 `cp` 命令（Copy）复制文件到指定目录下。**
- **如果要复制目录，需要在 `cp` 后加上 `-r` ，然后接上 `目录名 目标目录名`**



### 删除`rm`

- 使用 **`rm`** 命令删除文件
- 删除目录要加上 **`-r`** 选项，会删除目录和目录下的所有内容



### 移动文件/目录与重命名`mv`

- 使用 `mv` 命令可以移动文件或目录。
- `mv` 命令还可以用来重命名，如 `mv test1 test2`， 会把 `test1` 重命名为 `test2`



### 查看文件内容`cat`

- 使用方法：`cat 文件路径`
- 带行号的打印文件内容`cat -n 文件名`



## 帮助命令`man`

- 在 Linux 环境中，如果你遇到困难，可以使用 `man` 命令，它是 `Manual pages` 的缩写。例如输入 `man cat` ，可以获取 cat 命令的详细的帮助文件。进入到 man 的页面后，按 `q` 可以退出 man。
- 有些命令可以使用 `--help` 选项查看帮助文档。











































